import aQute.bnd.gradle.Bundle
import java.util.jar.JarFile
import java.util.jar.Manifest

plugins {
    id 'com.jfrog.artifactory'
    id 'com.github.johnrengelman.shadow' apply false
    id 'biz.aQute.bnd.builder' apply false
    id 'com.dorongold.task-tree'
}

ext.java8 = gradle.ext.java8 // See settings.gradle

subprojects {
    apply plugin: 'java'
    apply plugin: 'maven-publish'
    apply plugin: 'com.jfrog.artifactory'

    sourceCompatibility = '1.8'
    targetCompatibility = '1.8'

    tasks.withType(JavaCompile).configureEach {
        options.encoding = 'UTF-8'
    }

    group               = "co.paralleluniverse"
    version             = quasarVersion
    status              = "integration"
    description         = "Fibers, Channels and Actors for the JVM"
    ext.url             = "http://puniverse.github.com/quasar"
    ext.vendor          = "Parallel Universe Software Co."
    ext.licenseName1    = "The GNU Lesser General Public License, version 3"
    ext.licenseUrl1     = "http://www.gnu.org/licenses/lgpl-3.0.txt"
    ext.licenseName2    = "Eclipse Public License - v 1.0"
    ext.licenseUrl2     = "http://www.eclipse.org/legal/epl-v10.html"
    ext.scmUrl          = "https://github.com/corda/quasar"
    ext.scmConnection   = "https://github.com/corda/quasar.git"
    ext.distDir         = "$buildDir/dist"
    ext.isReleaseVersion = !version.endsWith("SNAPSHOT")
    ext.baselib         = "${rootProject.projectDir}/baselib"
    ext.java8 = rootProject.ext.java8
    ext.jdkVer = ext.java8 ? "8" : "7"
    ext.quasarJar = "${rootProject.projectDir}/quasar-core/build/libs/quasar-core-${version}${ext.java8 ? "" : "-jdk7"}.jar" // project(':quasar-core').jar.archivePath

    ext.drpWizVer = '3.2.3'
    ext.slf4jVer  = '1.7.25'
    ext.asmVer    = '5.2'
    ext.kotlinVer = kotlinVersion
    ext.osgiVer   = '7.0.0'

    if (!project.hasProperty('mainClass')) { // must use project.hasProperty() rather than hasProperty in subprojects (gradle bug)
        ext.mainClass = ''
    }


    repositories {
        flatDir {
            dirs baselib
        }
        repositories {
            mavenLocal()
            mavenCentral()
            maven { url "https://oss.sonatype.org/content/repositories/releases" }
            maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
            jcenter()
        }
    }

    configurations.all {
        resolutionStrategy {
            dependencySubstitution {
                // The substitution is needed to get ASM 5.2 whilst Kryo still depends on 5.0.4
                substitute module("org.ow2.asm:asm") with module("org.ow2.asm:asm:$asmVer")

                // Avoid problem when a transitive dependency on TestNG asks for Ant 1.9.7.
                substitute module("org.apache.ant:ant") with module("org.apache.ant:ant:1.9.9")

                // Avoid problem when DropWizard and Log4J ask for different versions of SLF4J.
                substitute module("org.slf4j:slf4j-api") with module("org.slf4j:slf4j-api:$slf4jVer")
            }
            failOnVersionConflict()
        }
    }

    configurations {
        provided
        timewarp
        // markdownDoclet

        compileClasspath.extendsFrom provided
        testCompileClasspath.extendsFrom provided
        testRuntimeClasspath.extendsFrom provided
    }

    sourceSets {
        jmh {
            compileClasspath += main.compileClasspath + main.output + test.compileClasspath + test.output
            runtimeClasspath += compileClasspath + main.runtimeClasspath + test.runtimeClasspath
        }
    }

    compileJmhJava {
        sourceCompatibility = '1.8'
        targetCompatibility = '1.8'
    }

    dependencies {
        implementation "io.dropwizard.metrics:metrics-core:$drpWizVer"
        provided "org.apache.ant:ant:1.9.9" // version 1.10 and upwards requires JDK 8
        implementation "com.google.guava:guava:20.0" // version 21.0 and upwards requires JDK 8
        timewarp 'co.paralleluniverse:timewarp:0.1.0-SNAPSHOT'
        testImplementation 'co.paralleluniverse:timewarp:0.1.0-SNAPSHOT'
        testImplementation 'junit:junit:4.12'
        testImplementation('com.google.truth:truth:0.34') {
            exclude group: 'com.google.guava', module: 'guava'
            exclude group: 'junit', module: 'junit'
        }
        testImplementation 'org.hamcrest:hamcrest-all:1.3'
        testImplementation("org.mockito:mockito-all:1.10.19") {
            exclude group: "org.ow2.asm", module: '*'
        }
        testImplementation "org.ow2.asm:asm:$asmVer"

        jmhImplementation 'org.openjdk.jmh:jmh-core:1.19'
        jmhImplementation 'org.openjdk.jmh:jmh-generator-annprocess:1.19'

        compileOnly 'org.kohsuke.metainf-services:metainf-services:1.7'
        // compileOnly 'com.google.auto.service:auto-service:1.0-rc1' // same as metainf-services
        // markdownDoclet "ch.raffael.pegdown-doclet:pegdown-doclet:1.1.1"
    }

    //    tasks.withType(JavaCompile) {
    //        // options.compilerArgs << "-Xlint:unchecked"
    //        // options.compilerArgs << "-Xlint:deprecation"
    //    }

    compileJava.dependsOn processResources
    compileJava {
        if (project.name != 'quasar-kotlin') {
            doLast {
                scanAndInstrument(sourceSets.main, [configurations.provided, configurations.runtimeClasspath])
            }
        }
    }

    test.dependsOn jar

    tasks.withType(Test).configureEach {
        useJUnit()
        // systemProperty 'co.paralleluniverse.fibers.verifyInstrumentation', 'true'

        // systemProperty "java.util.logging.config.file", "jul.properties"

        // Uncomment and add ${rootProject.projectDir}/log4j.xml, if not present, for logging
        // systemProperty "log4j.configurationFile", "${rootProject.projectDir}/log4j.xml"

        // systemProperty "Log4jContextSelector", "org.apache.logging.log4j.core.async.AsyncLoggerContextSelector"

        // systemProperty 'co.paralleluniverse.debugMode', 'true'
        systemProperty 'co.paralleluniverse.monitoring.flightRecorderLevel', '5'
        systemProperty 'co.paralleluniverse.globalFlightRecorder', 'true'
        systemProperty 'co.paralleluniverse.flightRecorderDumpFile', 'quasar.log'
        systemProperty 'co.paralleluniverse.monitoring.flightRecorderSize', '200000'

        if (project.name != 'quasar-core') {
            jvmArgs "-javaagent:${quasarJar}" // =vdmc (verbose, debug, allow monitors, check class)
        }

        if (project.name != 'quasar-kotlin') { // TODO investigate why kotlin-plugin 1.1.2+ doesn't like it
            jvmArgs "-Xbootclasspath/a:${configurations.timewarp.singleFile}"
            if (System.getenv("TRAVIS") == 'true') {
                jvmArgs "-javaagent:${configurations.timewarp.singleFile}=3" // slow clock down x3
            }
        }

        jvmArgs "-Xmx1024m"
        if (!project.ext.java8) {
            jvmArgs "-XX:MaxPermSize=512m" // Travis is having some trouble with PermGen
        }
        // jvmArgs "-XX:-UseCompressedOops"

        beforeTest { desc ->
            logger.quiet("Running test: " + desc)
        }

        afterTest { desc, result ->
            if(result.resultType == TestResult.ResultType.FAILURE) {
                logger.quiet("Failed test ${desc.name} [${desc.className}] with exception: ${result.exception}")
                if(result.exception != null) {
                    result.exception.printStackTrace()
                }
            }
        }

        doLast() {
            println "file://" + getReports().getHtml().getDestination() + "/index.html"
        }
    }

    ['run', 'debug'].each { name ->
        project.task(name, type: JavaExec, dependsOn:[testClasses]) {
            classpath = sourceSets.main.runtimeClasspath
            if(project.hasProperty('mainClass')){
                main = project.mainClass
            }
            if(project.hasProperty('args')){
                args project.args.split('\\s+')
            }

            jvmArgs '-Xmx2048m'
            // jvmArgs "-Xbootclasspath/p:${System.getProperty("user.home")}/jsr166.jar"
            // systemProperty 'co.paralleluniverse.fibers.DefaultFiberPool.parallelism', '1'

            systemProperty "log4j.configurationFile", "${rootProject.projectDir}/log4j.xml"
            systemProperty "Log4jContextSelector", "org.apache.logging.log4j.core.async.AsyncLoggerContextSelector"
            // systemProperty 'co.paralleluniverse.fibers.verifyInstrumentation', 'true'
            jvmArgs "-javaagent:${quasarJar}" // =vdmc (verbose, debug, allow monitors, check class)

            // jvmArgs '-XX:+UnlockCommercialFeatures', '-XX:+FlightRecorder', '-XX:StartFlightRecording=duration=60s,filename=recording.jfr,settings=heap'
        }
    }
    debug.debug = true

    project.afterEvaluate {
        run.dependsOn project(':quasar-core').tasks["jdk${project.ext.jdkVer}ShadowJar"]
    }

    tasks.withType(JavaExec).configureEach {
        classpath += sourceSets.test.runtimeClasspath + sourceSets.test.output + sourceSets.jmh.runtimeClasspath + sourceSets.jmh.output
    }

    //    tasks.withType(Debug) {
    //        classpath = sourceSets.test.runtimeClasspath
    //    }

    configure (javadoc) {
        classpath += configurations.provided
        options {
            // docletpath = configurations.markdownDoclet.files.asType(List)
            // doclet = 'ch.raffael.doclets.pegdown.PegdownDoclet'
            // addStringOption("parse-timeout", "10")
            if(project.ext.java8) {
                options.addStringOption('Xdoclint:none', '-quiet')
            }
            // stylesheetFile = rootProject.file('./baselib/javadoc.css')
            links = [
                "http://docs.oracle.com/javase/7/docs/api/",
                "http://google.github.io/guava/releases/19.0/api/docs/"
            ]
        }
    }

    defaultTasks 'build'

    task sourcesJar(type: Jar, dependsOn: classes) {
        archiveClassifier = 'sources'
        from sourceSets.main.allSource
    }
    task javadocJar(type: Jar, dependsOn: javadoc) {
        archiveClassifier = 'javadoc'
        from javadoc.destinationDir
    }

    task artifacts {
        group = "Help"
        description = "Displays the artifacts associated with each configuration of " + project
        doFirst {
            configurations.findAll().each { config ->
                println "${config}:"
                // config.allArtifacts.each { file -> println "--- " + file }
                config.allArtifacts.getFiles().each { file -> println "" + file }
                println ' '
            }
        }
    }

    ///////// Publish Artifacts
    apply plugin: 'maven'
    apply plugin: 'signing'

    artifacts {
        archives sourcesJar
        archives javadocJar
    }

    signing {
        required { isReleaseVersion && gradle.taskGraph.hasTask("uploadArchives") }
        sign configurations.archives
    }
}

def scanAndInstrument(SourceSet sset, configs) {

    def cp = sset.output.classesDirs.getAsPath() + ':' + sset.output.resourcesDir + ':' + configs*.asPath.join(':')

    // ENT-5598 quasar-kotlin has two output directories, java and kotlin.
    // So we have to cope with multiple directories in classesDirs.

    ant.taskdef(
        name:'scanSuspendables',
        classname:'co.paralleluniverse.fibers.instrument.SuspendablesScanner',
        classpath: cp)
    ant.scanSuspendables(
        auto: false,
        supersFile:"${sset.output.resourcesDir}/META-INF/suspendable-supers",
        append: true) {
        for (File f : sset.output.classesDirs) {
            fileset(dir: f)
        }
    }

    ant.taskdef(
        name:'instrumentation',
        classname:'co.paralleluniverse.fibers.instrument.InstrumentationTask',
        classpath: cp)
    ant.instrumentation(verbose:'true', check:'true', debug:'true') {
        for (File f : sset.output.classesDirs) {
            fileset(dir: f) {
                exclude(name: 'co/paralleluniverse/fibers/instrument/*.class')
            }
        }
    }
}

String fetchManifestAttributeFrom(File archive, String attributeName) {
    return new JarFile(archive).with { jar ->
        Manifest manifest = jar.manifest
        manifest.mainAttributes.getValue(attributeName)
    }
}

String fetchManifestAttributeFrom(TaskProvider<? extends Jar> task, String attributeName) {
    return fetchManifestAttributeFrom(task.flatMap { it.archiveFile }.get().asFile, attributeName)
}

project (':quasar-core') {
    /*
     * see:
     *   https://docs.gradle.org/current/userguide/java_plugin.html
     *   http://examples.javacodegeeks.com/core-java/gradle/gradle-sourcesets-example/
     *   http://stackoverflow.com/questions/15870662/gradle-create-a-new-jar-from-each-sourceset
     *   http://stackoverflow.com/questions/18190614/compiling-a-project-with-different-java-source-compatibility
     *   https://softnoise.wordpress.com/2014/09/07/gradle-sub-project-test-dependencies-in-multi-project-builds/
     */

    // remove default artifact
    configurations.runtime.artifacts.with { archives ->
        archives.each {
            archives.remove(it)
        }
    }

    [compileJava, compileTestJava, classes, jar]*.enabled = false

    sourceSets {
        main {
            java {
                srcDir 'src/main/java'
                srcDir 'src/jdk8/java'
            }
        }

        jdk8 {
            java {
                srcDir 'src/main/java'
                srcDir 'src/jdk8/java'
            }

            compileClasspath += main.compileClasspath
            runtimeClasspath += compileClasspath
        }

        jdk8test {
            java {
                srcDir 'src/test/java'
                srcDir 'src/jdk8test/java'
            }

            compileClasspath += jdk8.output + test.compileClasspath
            runtimeClasspath += compileClasspath + test.runtimeClasspath
        }

        jmh {
            java {
                srcDir 'src/jmh/java'
            }

            compileClasspath += jdk8.output + jdk8test.compileClasspath + jdk8test.output
            runtimeClasspath += compileClasspath + jdk8test.runtimeClasspath
        }

        classloadertest {
            java {
                srcDir 'src/classloadertest/java'
            }

            compileClasspath += jdk8.output + test.compileClasspath
            runtimeClasspath += compileClasspath + test.runtimeClasspath
        }
    }

    configurations {
        compileClasspath.extendsFrom provided
        jdk8Archives.extendsFrom runtimeClasspath
    }

    dependencies {
        implementation ":high-scale-lib"
        implementation "org.hdrhistogram:HdrHistogram:2.1.9"
        implementation("org.latencyutils:LatencyUtils:2.0.3") {
            exclude group: "org.hdrhistogram", module: '*'
        }
        provided "org.ow2.asm:asm:$asmVer"
        provided "org.ow2.asm:asm-analysis:$asmVer"
        provided "org.ow2.asm:asm-commons:$asmVer"
        provided "org.ow2.asm:asm-util:$asmVer"

        implementation "com.esotericsoftware:kryo:4.0.2"
        implementation "de.javakaffee:kryo-serializers:0.43"
        provided 'junit:junit:4.12'

        compileOnly "org.osgi:osgi.annotation:$osgiVer"
    }

    def ssets = [sourceSets.jdk8]

    ssets.each { set ->
        project.tasks.named("compile${capitalize(set.name)}Java", JavaCompile) {
            // Ensure that the resources output directory has already been created.
            dependsOn "process${capitalize(set.name)}Resources"
            doLast {
                rootProject.scanAndInstrument(set, [configurations["${set.name}Runtime"], configurations.provided, configurations.runtimeClasspath])
            }
        }

        Jar shadowJarTask = task("${set.name}ShadowJar", type: com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar, dependsOn: classes) {
            destinationDirectory = file("$buildDir/libs")
            archiveClassifier = ''

            from set.output

            configurations = [
                project.configurations.compileClasspath,
                project.configurations["${set.name}Runtime"]
            ]
            dependencies {
                include(dependency('org.ow2.asm:.*:.*'))
                include(dependency(':high-scale-lib'))
            }
            exclude 'META-INF/INDEX.LIST'

            relocate 'org.objectweb.asm.', 'co.paralleluniverse.asm.'

            manifest {
                attributes(
                    "Built-By"                  :   System.getProperty("user.name"),
                    "Implementation-Title"      :   project.name,
                    "Implementation-Version"    :   archiveVersion.get(),
                    "Implementation-Vendor"     :   vendor,
                    "Premain-Class"             :   "co.paralleluniverse.fibers.instrument.JavaAgent",
                    "Agent-Class"               :   "co.paralleluniverse.fibers.instrument.JavaAgent",
                    "Can-Retransform-Classes"   :   "true",
                    "Can-Redefine-Classes"      :   "true",
                    //  "Class-Path"                :   configurations.runtime.collect { "lib/"+it.getName() }.join(',')
                )
            }
        }

        def bundleTask = tasks.register("${set.name}Bundle", Bundle) {
            dependsOn shadowJarTask
            from(zipTree(shadowJarTask.archiveFile)) {
                exclude 'META-INF/suspendable*'
                exclude 'co/paralleluniverse/asm/**'
                exclude 'co/paralleluniverse/common/asm/**'
                exclude 'co/paralleluniverse/common/resource/**'
                exclude 'co/paralleluniverse/fibers/instrument/**'
            }
            archiveAppendix = 'osgi'

            manifest {
                attributes(
                    "Built-By"                  :   System.getProperty("user.name"),
                    "Implementation-Title"      :   project.name,
                    "Implementation-Version"    :   archiveVersion.get(),
                    "Implementation-Vendor"     :   vendor
                )
            }

            bnd """
Bundle-SymbolicName: co.paralleluniverse.quasar-core
Bundle-Name: Quasar Fibers
Bundle-Version: \${project.version}
Import-Package: \
 org.LatencyUtils.*;resolution:=optional,\
 org.HdrHistogram.*;resolution:=optional,\
 org.junit.*;resolution:=optional,\
 *
"""
        }

        def validateBundle = tasks.register("${set.name}ValidateBundle") {
            dependsOn bundleTask
            doLast {
                String importPackages = fetchManifestAttributeFrom(bundleTask, 'Import-Package')
                if (importPackages && importPackages.contains('co.paralleluniverse.asm')) {
                    throw new InvalidUserCodeException("OSGi bundle should not import shaded ASM package: " + importPackages)
                }
            }
        }

        bundleTask.configure {
            it.finalizedBy validateBundle
        }

        def bundleAgentTask = tasks.register("${set.name}AgentBundle", Bundle) {
            dependsOn shadowJarTask
            from(zipTree(shadowJarTask.archiveFile)) {
                include 'META-INF/suspendable*'
                include 'co/paralleluniverse/asm/**'
                include 'co/paralleluniverse/common/asm/**'
                include 'co/paralleluniverse/common/resource/**'
                include 'co/paralleluniverse/fibers/instrument/**'
                exclude 'co/paralleluniverse/fibers/instrument/InstrumentationTask*'
                exclude 'co/paralleluniverse/fibers/instrument/InstrumentationTKB*'
                exclude 'co/paralleluniverse/fibers/instrument/OldSuspendablesScanner*'
                exclude 'co/paralleluniverse/fibers/instrument/QuasarURLClassLoader*'
                exclude 'co/paralleluniverse/fibers/instrument/SuspendablesScanner*'
            }
            archiveAppendix = 'osgi'
            archiveClassifier = 'agent'

            bnd shadowJarTask.archiveFile.map { file ->
                "-include: jar:${file.asFile.toURI()}!/META-INF/MANIFEST.MF"
            }

            bnd """
Bundle-SymbolicName: co.paralleluniverse.quasar-core.agent
Bundle-Name: Quasar Agent
Bundle-Version: \${project.version}
"""
        }

        def validateAgentBundle = tasks.register("${set.name}ValidateAgentBundle") {
            dependsOn bundleAgentTask
            doLast {
                String importPackages = fetchManifestAttributeFrom(bundleAgentTask, 'Import-Package')
                if (importPackages && !importPackages.equals("co.paralleluniverse.common.resource")) {
                    throw new InvalidUserDataException("OSGi bundle for Java agent should only import from itself: " + importPackages)
                }
            }
        }

        bundleAgentTask.configure {
            it.finalizedBy validateAgentBundle
        }

        def testTask = task("${set.name}Test", type: Test, dependsOn: [shadowJarTask, compileClassloadertestJava]) {
            testClassesDirs = project.sourceSets["${set.name}test"].output.classesDirs
            classpath = project.sourceSets["${set.name}test"].runtimeClasspath
            project.afterEvaluate {
                jvmArgs "-javaagent:${shadowJarTask.archiveFile.get()}" // =vdc
            }
        }

        artifacts {
            archives shadowJarTask
        }

        signArchives.dependsOn shadowJarTask, bundleTask, bundleAgentTask
        artifactoryPublish.dependsOn shadowJarTask, bundleTask, bundleAgentTask

        test.dependsOn testTask
    }

    def jdk8ShadowJar = tasks.named('jdk8ShadowJar')
    def jdk8Bundle = tasks.named('jdk8Bundle', Bundle)
    def jdk8AgentBundle = tasks.named('jdk8AgentBundle', Bundle)

    if (ext.java8) {
        compileJdk8Java {
            sourceCompatibility = '1.8'
            targetCompatibility = '1.8'
        }

        compileJdk8testJava {
            sourceCompatibility = '1.8'
            targetCompatibility = '1.8'
        }

        artifacts {
            jdk8Archives jdk8ShadowJar.flatMap { it.archiveFile }
        }

        tasks.withType(JavaExec).configureEach {
            classpath += sourceSets.jdk8test.runtimeClasspath + sourceSets.jdk8test.output
        }
        run.dependsOn compileJdk8Java, jdk8testClasses
    }

    javadoc {
        options.encoding = 'UTF-8'
        source = sourceSets.jdk8.allJava
    }

    def installer = install.repositories.mavenInstaller

    [installer]*.pom*.whenConfigured {
        it.dependencies.removeAll { dep ->
            dep.artifactId.startsWith('jsr166e') ||
            dep.artifactId.startsWith('high-scale-lib') ||
            dep.groupId == 'org.ow2.asm'
        }
    }

    if (ext) {
        artifacts {
            archives sourcesJar
            archives javadocJar
        }
    }
    ext {
        mavenArtifacts = {
            it.artifact jdk8ShadowJar.flatMap { it.archiveFile }

            it.pom{ pom->
                pom.withXml{ xml ->
                    def dependenciesNode = xml.asNode().appendNode('dependencies')
                    project.configurations.jdk8Archives.allDependencies.each {
                        if (! (it instanceof SelfResolvingDependency)) {
                            def dependencyNode = dependenciesNode.appendNode('dependency')
                            dependencyNode.appendNode('groupId', it.group)
                            dependencyNode.appendNode('artifactId', it.name)
                            dependencyNode.appendNode('version', it.version)
                            dependencyNode.appendNode('scope', 'runtime')
                        }
                    }

                }
            }
        }

        osgiArtifacts = {
            it.artifact jdk8Bundle.flatMap { it.archiveFile }
            it.artifact source: jdk8AgentBundle.flatMap { it.archiveFile }, classifier: jdk8AgentBundle.flatMap { it.archiveClassifier }.get()

            it.pom { pom->
                pom.withXml { xml ->
                    def dependenciesNode = xml.asNode().appendNode('dependencies')
                    project.configurations.jdk8Archives.allDependencies.each {
                        if (! (it instanceof SelfResolvingDependency)) {
                            def dependencyNode = dependenciesNode.appendNode('dependency')
                            dependencyNode.appendNode('groupId', it.group)
                            dependencyNode.appendNode('artifactId', it.name)
                            dependencyNode.appendNode('version', it.version)
                            dependencyNode.appendNode('scope', 'runtime')
                        }
                    }
                }
            }
        }
    }
}

project (':quasar-actors') {
    //project.evaluationDependsOn(':quasar-core')

    dependencies {
        provided project(path: ':quasar-core', configuration: "jdk${jdkVer}Archives")
        // compile 'org.mutabilitydetector:MutabilityDetector:0.9.2'
        implementation "org.slf4j:slf4j-api:$slf4jVer"
        implementation "net.bytebuddy:byte-buddy:1.7.1"
        testRuntimeOnly "org.apache.logging.log4j:log4j-slf4j-impl:2.8.2"
        testRuntimeOnly "org.apache.logging.log4j:log4j-api:2.8.2"
        testRuntimeOnly "org.apache.logging.log4j:log4j-core:2.8.2"
        testRuntimeOnly "com.lmax:disruptor:3.3.6" // required for log4j
    }
}

project (':quasar-reactive-streams') {
    //project.evaluationDependsOn(':quasar-core')

    dependencies {
        provided project(path: ':quasar-core', configuration: "jdk${jdkVer}Archives")
        compile "org.reactivestreams:reactive-streams:1.0.0"
        testCompile("org.reactivestreams:reactive-streams-tck:1.0.0") {
            exclude group: "junit", module: "*"
            exclude group: "org.testng", module: "testng"
        }
        testCompile('org.testng:testng:6.12') {
            exclude group: "com.google.guava", module: "*"
            exclude group: "junit", module: "*"
        }
    }

    test {
        useTestNG()
    }
}

project (':quasar-disruptor') {
    //project.evaluationDependsOn(':quasar-core')

    dependencies {
        provided project(path: ':quasar-core', configuration: "jdk${jdkVer}Archives")
        compile "com.lmax:disruptor:3.3.6"
    }
}

task javadoc(type: Javadoc, dependsOn: subprojects.javadoc) {
    title = "Quasar ${project(':quasar-core').version}"
    destinationDir = file("docs/javadoc")

    source = project(':quasar-core').sourceSets.jdk8.allJava
    source += project(':quasar-actors').sourceSets.main.allJava
    source += project(':quasar-reactive-streams').sourceSets.main.allJava

    classpath = files(subprojects.collect { project -> project.sourceSets.main.compileClasspath })
    options {
        // docletpath = project(':quasar-core').configurations.markdownDoclet.files.asType(List)
        // doclet = 'ch.raffael.doclets.pegdown.PegdownDoclet'
        // addStringOption("parse-timeout", "10")
        // stylesheetFile = rootProject.file('./baselib/javadoc.css')
        if(project.ext.java8) {
            options.addStringOption('Xdoclint:none', '-quiet')
        }
        links = [
        "http://docs.oracle.com/javase/7/docs/api/",
        "http://docs.guava-libraries.googlecode.com/git-history/v18.0/javadoc/"
        ]
    }
    excludes = [
        "co/paralleluniverse/actors/spi/**",
        "co/paralleluniverse/actors/ActorMonitor.java",
        "co/paralleluniverse/actors/GlobalRegistry.java",
        "co/paralleluniverse/actors/JMXActorMonitor.java",
        "co/paralleluniverse/actors/LifecycleListener.java",
        "co/paralleluniverse/actors/LifecycleListenerProxy.java",
        "co/paralleluniverse/actors/MutabilityTester.java",
        "co/paralleluniverse/actors/RemoteActorProxyFactoryService.java",
        "co/paralleluniverse/actors/RemoteActorRef.java",
        "co/paralleluniverse/actors/RemoteActorProxyFactory.java",
        "co/paralleluniverse/common/benchmark/**",
        "co/paralleluniverse/common/classloader/**",
        "co/paralleluniverse/common/logging/**",
        "co/paralleluniverse/common/monitoring/**",
        "co/paralleluniverse/common/reflection/**",
        "co/paralleluniverse/common/test/**",
        "co/paralleluniverse/common/util/**",
        "co/paralleluniverse/concurrent/forkjoin/**",
        "co/paralleluniverse/concurrent/util/**",
        "co/paralleluniverse/data/record/DynamicGeneratedRecord.java",
        "co/paralleluniverse/data/record/DynamicRecord.java",
        "co/paralleluniverse/fibers/DefaultFiberPool.java",
        "co/paralleluniverse/fibers/FibersMonitor.java",
        "co/paralleluniverse/fibers/FiberTimedScheduler.java",
        "co/paralleluniverse/fibers/Instrumented.java",
        "co/paralleluniverse/fibers/NoopFibersMonitor.java",
        "co/paralleluniverse/fibers/instrument/**",
        "co/paralleluniverse/io/serialization/**",
        "co/paralleluniverse/remote/**",
        "co/paralleluniverse/strands/channels/SelectActionImpl.java",
        "co/paralleluniverse/strands/channels/disruptor/**", // not ready
        "co/paralleluniverse/strands/queues/**",
    ]
}

task clean(dependsOn: subprojects.clean) {
    doLast {
        delete 'docs/javadoc'
    }
}

def capitalize(s) { s[0].toUpperCase() + s[1..-1].toLowerCase() }

def publishedProjects = subprojects

configure(publishedProjects) { subproject ->
    apply plugin: 'java'
    apply plugin: 'maven-publish'
    apply plugin: 'com.jfrog.artifactory'

  task sourceJar(type: Jar, dependsOn: subproject.classes) {
    archiveClassifier = 'sources'
    from sourceSets.main.allSource
  }

//  task javadocJar(type: Jar, dependsOn: subproject.javadoc) {
//    classifier = 'javadoc'
//    from javadoc.destinationDir
//  }
//
    publishing {
        publications {
            if (subproject.hasProperty('osgiArtifacts')) {
                create(subproject.name + '-osgi', MavenPublication) {
                    subproject.osgiArtifacts.call(it)
                    alias true

                    groupId subproject.group
                    artifactId subproject.name + '-osgi'
                    artifact tasks.sourceJar
                    artifact tasks.javadocJar

                    pom {
                        name = subproject.name + '-osgi'
                        packaging = 'jar'
                        description = subproject.description
                        url = subproject.url

                        scm {
                            url = subproject.scmUrl
                            connection = subproject.scmConnection
                            developerConnection = subproject.scmConnection
                        }
                        licenses {
                            license {
                                name = subproject.licenseName1
                                url = subproject.licenseUrl1
                                distribution = 'repo'
                            }
                            license {
                                name = subproject.licenseName2
                                url = subproject.licenseUrl2
                                distribution = 'repo'
                            }
                        }
                    }
                    pom.withXml {
                        Node pomNode = asNode()
                        pomNode.dependencies.'*'.findAll() {
                            it.artifactId.text().startsWith('jsr166e') ||
                                it.artifactId.text().startsWith('high-scale-lib') ||
                                it.artifactId.text().startsWith('org.ow2.asm')
                        }.each() {
                            it.parent().remove(it)
                        }
                    }
                }
            }

            create(subproject.name, MavenPublication) {

//                if (subproject.name == "quasar-core"){
//                    subproject.shadow.component(it)
                if (subproject.hasProperty("mavenArtifacts")) {
                    subproject.mavenArtifacts.call(it)
                } else {
                    from components.java
                }

                groupId subproject.group
                artifactId subproject.name
                artifact tasks.sourceJar
                artifact tasks.javadocJar


                pom {
                    name = subproject.name
                    packaging = 'jar'
                    description = subproject.description
                    url = subproject.url

                    scm {
                        url = subproject.scmUrl
                        connection = subproject.scmConnection
                        developerConnection = subproject.scmConnection
                    }
                    licenses {
                        license {
                            name = subproject.licenseName1
                            url = subproject.licenseUrl1
                            distribution = 'repo'
                        }
                        license {
                            name = subproject.licenseName2
                            url = subproject.licenseUrl2
                            distribution = 'repo'
                        }
                    }
                    developers {
                        developer {
                            id = 'pron'
                            name = 'Ron Pressler'
                        }
                    }
                }
                pom.withXml {
                    Node pomNode = asNode()
                    pomNode.dependencies.'*'.findAll() {
                        it.artifactId.text().startsWith('jsr166e') ||
                                it.artifactId.text().startsWith('high-scale-lib') ||
                                it.artifactId.text().startsWith('org.ow2.asm')
                    }.each() {
                        it.parent().remove(it)
                    }
                }
            }
        }
    }
}

artifactory {
    publish {
        contextUrl = 'https://ci-artifactory.corda.r3cev.com/artifactory'
        repository {
            repoKey = 'corda-dependencies-dev'
            username = project.findProperty('cordaArtifactoryUsername') ?: System.getenv('CORDA_ARTIFACTORY_USERNAME') ?: System.getProperty('corda.artifactory.username')
            password = project.findProperty('cordaArtifactoryPassword') ?: System.getenv('CORDA_ARTIFACTORY_PASSWORD') ?: System.getProperty('corda.artifactory.password')
            maven = true
        }

        defaults {
            if (publishedProjects.contains(project)) {
                publications(project.name)
                publications(project.name + '-osgi')
            }
        }
    }
}
